name: Build All Platforms

# é…ç½®å·¥ä½œæµæƒé™
permissions:
  actions: write
  contents: write  # éœ€è¦å†™æƒé™æ¥åˆ›å»º Release

on:
  workflow_dispatch:
    inputs:
      platforms:
        description: 'Select platform to build'
        type: choice
        required: true
        default: 'all'
        options:
          - all
          - mipsel-21.02.7
          - mipsel-23.05.0
          - x86_64-21.02.7
          - x86_64-22.03.7
          - x86_64-24.10.4

jobs:
  # æ£€æŸ¥è¦æ„å»ºçš„å¹³å°
  check-platforms:
    runs-on: ubuntu-latest
    outputs:
      selected-platform: ${{ steps.check.outputs.selected-platform }}
    steps:
      - name: Check platforms to build
        id: check
        run: |
          platforms="${{ github.event.inputs.platforms || 'all' }}"
          echo "Selected platform: $platforms"
          echo "selected-platform=$platforms" >> $GITHUB_OUTPUT

  # ç»Ÿä¸€æ„å»ºå’Œæ”¶é›†ä½œä¸š
  build-and-collect:
    needs: check-platforms
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Create artifacts directory
        run: mkdir -p artifacts
        
      - name: Trigger and wait for platform builds
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // éœ€è¦è§¦å‘çš„å·¥ä½œæµåˆ—è¡¨åŠå…¶å¯¹åº”çš„å¹³å°æ£€æŸ¥
            const workflows = [
              { file: 'build-mipsel_24kc-openwrt-21.02.7.yml', platform: 'mipsel-21.02.7' },
              { file: 'build-mipsel_24kc-openwrt-23.05.0.yml', platform: 'mipsel-23.05.0' },
              { file: 'build-x86_64-openwrt-21.02.7.yml', platform: 'x86_64-21.02.7' },
              { file: 'build-x86_64-openwrt-22.03.7.yml', platform: 'x86_64-22.03.7' },
              { file: 'build-x86_64-openwrt-24.10.4.yml', platform: 'x86_64-24.10.4' }
            ];
            
            const selectedPlatform = '${{ needs.check-platforms.outputs.selected-platform }}';
            console.log(`Selected platform: ${selectedPlatform}`);
            
            // è¿‡æ»¤éœ€è¦æ„å»ºçš„å·¥ä½œæµ
            const workflowsToTrigger = workflows.filter(w => {
              if (selectedPlatform === 'all') return true;
              return selectedPlatform === w.platform;
            });
            
            console.log(`Will trigger ${workflowsToTrigger.length} workflows`);
            
            const triggeredRuns = [];
            
            // è§¦å‘å·¥ä½œæµå¹¶è®°å½•è¿è¡ŒID
            for (const workflow of workflowsToTrigger) {
              try {
                console.log(`Triggering ${workflow.file}...`);
                
                // å…ˆè·å–è§¦å‘å‰çš„æœ€æ–°è¿è¡ŒID
                const beforeRuns = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow.file,
                  per_page: 1
                });
                
                const beforeRunId = beforeRuns.data.workflow_runs.length > 0 ? beforeRuns.data.workflow_runs[0].id : null;
                
                const response = await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow.file,
                  ref: context.ref
                });
                
                console.log(`Triggered ${workflow.file} successfully`);
                
                // ç­‰å¾…æ–°è¿è¡Œå‡ºç°
                let newRunId = null;
                let attempts = 0;
                const maxAttempts = 12; // æœ€å¤šç­‰å¾…60ç§’
                
                while (attempts < maxAttempts && !newRunId) {
                  await new Promise(resolve => setTimeout(resolve, 5000));
                  attempts++;
                  
                  const afterRuns = await github.rest.actions.listWorkflowRuns({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    workflow_id: workflow.file,
                    per_page: 5
                  });
                  
                  // æŸ¥æ‰¾æ–°çš„è¿è¡Œï¼ˆIDä¸åŒäºè§¦å‘å‰çš„è¿è¡Œï¼‰
                  for (const run of afterRuns.data.workflow_runs) {
                    if (run.id !== beforeRunId && run.status !== 'completed') {
                      newRunId = run.id;
                      break;
                    }
                  }
                }
                
                if (newRunId) {
                  triggeredRuns.push({
                    workflow: workflow.file,
                    platform: workflow.platform,
                    runId: newRunId
                  });
                  console.log(`Recorded new run ID ${newRunId} for ${workflow.file}`);
                } else {
                  console.log(`Failed to find new run for ${workflow.file}`);
                }
                
              } catch (error) {
                console.log(`Error triggering ${workflow.file}: ${error.message}`);
              }
            }
            
            console.log(`Triggered ${triggeredRuns.length} workflows, now waiting for completion...`);
            
            // ç­‰å¾…æ‰€æœ‰å·¥ä½œæµå®Œæˆ
            const maxWaitTime = 60 * 60 * 1000; // 1 hour
            const checkInterval = 30 * 1000; // 30 seconds
            const startTime = Date.now();
            
            while (Date.now() - startTime < maxWaitTime) {
              let allCompleted = true;
              
              for (const run of triggeredRuns) {
                if (run.completed) continue;
                
                try {
                  const runDetails = await github.rest.actions.getWorkflowRun({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: run.runId
                  });
                  
                  console.log(`${run.workflow} (${run.runId}): ${runDetails.data.status} - ${runDetails.data.conclusion}`);
                  
                  if (runDetails.data.status === 'completed') {
                    run.completed = true;
                    run.conclusion = runDetails.data.conclusion;
                    console.log(`âœ… ${run.workflow} completed with ${run.conclusion}`);
                  } else {
                    allCompleted = false;
                  }
                } catch (error) {
                  console.log(`Error checking ${run.workflow}: ${error.message}`);
                  allCompleted = false;
                }
              }
              
              if (allCompleted) {
                console.log('ğŸ‰ All workflows completed!');
                break;
              }
              
              console.log('â³ Waiting for workflows to complete...');
              await new Promise(resolve => setTimeout(resolve, checkInterval));
            }
            
            // æ£€æŸ¥æ˜¯å¦è¶…æ—¶
            if (Date.now() - startTime >= maxWaitTime) {
              throw new Error('â° Timeout waiting for workflows to complete');
            }
            
            // æ”¶é›†artifacts
            const artifactsList = [];
            
            for (const run of triggeredRuns) {
              if (run.conclusion === 'success') {
                try {
                  const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: run.runId
                  });
                  
                  for (const artifact of artifacts.data.artifacts) {
                    console.log(`Found artifact: ${artifact.name} from ${run.workflow}`);
                    artifactsList.push({
                      name: artifact.name,
                      workflow: run.workflow,
                      platform: run.platform,
                      download_url: artifact.archive_download_url,
                      size: artifact.size_in_bytes
                    });
                  }
                } catch (error) {
                  console.log(`Error collecting artifacts from ${run.workflow}: ${error.message}`);
                }
              } else {
                console.log(`âš ï¸ Skipping artifacts from ${run.workflow} (${run.conclusion})`);
              }
            }
            
            // ä¿å­˜artifactsä¿¡æ¯ï¼Œä¾›åç»­æ­¥éª¤ä½¿ç”¨
            fs.writeFileSync('artifacts-list.json', JSON.stringify(artifactsList, null, 2));
            console.log(`ğŸ“¦ Collected ${artifactsList.length} artifacts total`);
            
            return { triggeredRuns, artifactsList };

      - name: Download and collect build artifacts
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // è¯»å–æ„ä»¶åˆ—è¡¨
            const artifactsList = JSON.parse(fs.readFileSync('artifacts-list.json', 'utf8'));
            console.log(`ğŸ“¦ Processing ${artifactsList.length} artifacts`);
            
            // åˆ›å»ºå‘å¸ƒç›®å½•ç»“æ„
            const releaseDir = 'release-files';
            fs.mkdirSync(releaseDir, { recursive: true });
            
            // ä¸ºæ¯ä¸ªæ„ä»¶ä¸‹è½½æ–‡ä»¶
            for (const artifact of artifactsList) {
              try {
                console.log(`â¬‡ï¸ Downloading artifact: ${artifact.name}`);
                
                // ä» download_url ä¸­æå– artifact ID
                const artifactId = parseInt(artifact.download_url.split('/artifacts/')[1].split('/zip')[0]);
                
                // ä¸‹è½½æ„ä»¶
                const download = await github.rest.actions.downloadArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifactId,
                  archive_format: 'zip',
                });
                
                // ä¿å­˜åˆ°æ–‡ä»¶
                const fileName = `${artifact.name}.zip`;
                const filePath = path.join(releaseDir, fileName);
                fs.writeFileSync(filePath, Buffer.from(download.data));
                
                console.log(`âœ… Downloaded: ${fileName} (${(download.data.byteLength / 1024).toFixed(1)} KB)`);
                
              } catch (error) {
                console.log(`âŒ Failed to download ${artifact.name}: ${error.message}`);
              }
            }
            
            // åˆ›å»ºæ„å»ºä¿¡æ¯æ–‡ä»¶
            const buildInfo = {
              build_time: new Date().toISOString(),
              repository: context.repo.full_name,
              commit_sha: context.sha,
              workflow_run_id: context.runId,
              artifacts: artifactsList.map(a => ({
                name: a.name,
                platform: a.name.includes('mipsel') ? 
                  (a.name.includes('21.02.7') ? 'mipsel_24kc-openwrt-21.02.7' : 'mipsel_24kc-openwrt-23.05.0') :
                  (a.name.includes('21.02.7') ? 'x86_64-openwrt-21.02.7' : 
                   a.name.includes('22.03.7') ? 'x86_64-openwrt-22.03.7' : 'x86_64-openwrt-24.10.4'),
                size_bytes: a.size_in_bytes,
                created_at: a.created_at
              }))
            };
            
            fs.writeFileSync(path.join(releaseDir, 'build-info.json'), JSON.stringify(buildInfo, null, 2));
            
            console.log(`ğŸ“‹ Created build info with ${buildInfo.artifacts.length} artifacts`);

      - name: Create README for release
        run: |
          cat > release-files/README.md << 'EOF'
          # ESurfing Client - Multi-Platform Build
          
          This release contains ESurfing Client binaries for multiple OpenWrt platforms.
          
          ## ğŸ“¦ Available Platforms
          
          - **mipsel_24kc-openwrt-21.02.7** - For MIPS routers (OpenWrt 21.02.7)
          - **mipsel_24kc-openwrt-23.05.0** - For MIPS routers (OpenWrt 23.05.0)
          - **x86_64-openwrt-21.02.7** - For x86_64 systems (OpenWrt 21.02.7)
          - **x86_64-openwrt-22.03.7** - For x86_64 systems (OpenWrt 22.03.7)
          - **x86_64-openwrt-24.10.4** - For x86_64 systems (OpenWrt 24.10.4)
          
          ## ğŸš€ Installation Instructions
          
          1. Download the appropriate `.zip` file for your platform
          2. Extract the contents to get the `.ipk` package
          3. Upload to your OpenWrt device
          4. Install using: `opkg install esurfingclient_*.ipk`
          5. Configure and start the service
          
          ## ğŸ“‹ Build Information
          
          - **Build Date**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          - **Repository**: ${{ github.repository }}
          - **Commit**: ${{ github.sha }}
          - **Workflow Run**: ${{ github.run_id }}
          
          ## ğŸ“„ Files Included
          
          - `build-info.json` - Detailed build information
          - `esurfingclient-*.zip` - Platform-specific packages
          
          For more information and source code, visit: https://github.com/${{ github.repository }}
          EOF
          
          echo "âœ… Created README for release"

      - name: Generate release tag and name
        id: release_info
        run: |
          # ç”ŸæˆåŸºäºæ—¶é—´çš„æ ‡ç­¾å’Œå‘å¸ƒåç§°
          TIMESTAMP=$(date -u +"%Y%m%d-%H%M%S")
          RELEASE_TAG="build-${TIMESTAMP}"
          RELEASE_NAME="ESurfing Client Build - $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          
          echo "release_tag=${RELEASE_TAG}" >> $GITHUB_OUTPUT
          echo "release_name=${RELEASE_NAME}" >> $GITHUB_OUTPUT
          
          echo "ğŸ·ï¸ Release tag: ${RELEASE_TAG}"
          echo "ğŸ“ Release name: ${RELEASE_NAME}"

      - name: Create GitHub Release
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.release_info.outputs.release_tag }}
          name: ${{ steps.release_info.outputs.release_name }}
          body: |
            # ESurfing Client - Multi-Platform Build
            
            ğŸš€ **Automated build containing binaries for multiple OpenWrt platforms**
            
            ## ğŸ“¦ Available Platforms
            
            - **mipsel_24kc-openwrt-21.02.7** - For MIPS routers (OpenWrt 21.02.7)
            - **mipsel_24kc-openwrt-23.05.0** - For MIPS routers (OpenWrt 23.05.0)
            - **x86_64-openwrt-21.02.7** - For x86_64 systems (OpenWrt 21.02.7)
            - **x86_64-openwrt-22.03.7** - For x86_64 systems (OpenWrt 22.03.7)
            - **x86_64-openwrt-24.10.4** - For x86_64 systems (OpenWrt 24.10.4)
            
            ## ğŸ”§ Installation Instructions
            
            1. Download the appropriate `.zip` file for your platform from the assets below
            2. Extract the contents to get the `.ipk` package
            3. Upload to your OpenWrt device
            4. Install using: `opkg install esurfingclient_*.ipk`
            5. Configure and start the service
            
            ## ğŸ“‹ Build Information
            
            - **Build Date**: ${{ steps.release_info.outputs.release_name }}
            - **Repository**: ${{ github.repository }}
            - **Commit**: ${{ github.sha }}
            - **Workflow Run**: ${{ github.run_id }}
            
            ## ğŸ“„ Assets Description
            
            - `README.md` - Detailed installation and usage instructions
            - `build-info.json` - Complete build metadata and artifact information
            - `esurfingclient-*.zip` - Platform-specific packages (one for each supported platform)
            
            ---
            
            *This release was automatically generated by GitHub Actions*
          files: release-files/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update workflow summary
        run: |
          echo "## ğŸ‰ Release Created Successfully!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Release Tag**: \`${{ steps.release_info.outputs.release_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Release Name**: ${{ steps.release_info.outputs.release_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**ğŸ”— Release URL**: https://github.com/${{ github.repository }}/releases/tag/${{ steps.release_info.outputs.release_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“¦ Available Downloads" >> $GITHUB_STEP_SUMMARY
          echo "- README.md - Installation instructions" >> $GITHUB_STEP_SUMMARY
          echo "- build-info.json - Build metadata" >> $GITHUB_STEP_SUMMARY
          echo "- esurfingclient-*.zip - Platform-specific packages" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ğŸ‰ Release created successfully!"
          echo "ğŸ”— Release URL: https://github.com/${{ github.repository }}/releases/tag/${{ steps.release_info.outputs.release_tag }}"
          echo "**Release Tag**: \`${{ steps.release_info.outputs.release_tag }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Release Name**: ${{ steps.release_info.outputs.release_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**ğŸ”— Release URL**: https://github.com/${{ github.repository }}/releases/tag/${{ steps.release_info.outputs.release_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“¦ Available Downloads" >> $GITHUB_STEP_SUMMARY
          echo "- README.md - Installation instructions" >> $GITHUB_STEP_SUMMARY
          echo "- build-info.json - Build metadata" >> $GITHUB_STEP_SUMMARY
          echo "- esurfingclient-*.zip - Platform-specific packages" >> $GITHUB_STEP_SUMMARY
          
      - name: Check overall result
        run: |
          echo "âœ… All selected builds completed successfully"
          echo "ğŸ‰ Release created with all platform binaries"
          echo "ğŸ”— Download from: https://github.com/${{ github.repository }}/releases/tag/${{ steps.release_info.outputs.release_tag }}"