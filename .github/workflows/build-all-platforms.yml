name: Build All Platforms

# é…ç½®å·¥ä½œæµæƒé™
permissions:
  actions: write
  contents: read

on:
  workflow_dispatch:
    inputs:
      platforms:
        description: 'Select platform to build'
        type: choice
        required: true
        default: 'all'
        options:
          - all
          - mipsel-21.02.7
          - mipsel-23.05.0
          - x86_64-21.02.7
          - x86_64-22.03.7
          - x86_64-24.10.4

jobs:
  # æ£€æŸ¥è¦æ„å»ºçš„å¹³å°
  check-platforms:
    runs-on: ubuntu-latest
    outputs:
      selected-platform: ${{ steps.check.outputs.selected-platform }}
    steps:
      - name: Check platforms to build
        id: check
        run: |
          platforms="${{ github.event.inputs.platforms || 'all' }}"
          echo "Selected platform: $platforms"
          echo "selected-platform=$platforms" >> $GITHUB_OUTPUT

  # ç»Ÿä¸€æ„å»ºå’Œæ”¶é›†ä½œä¸š
  build-and-collect:
    needs: check-platforms
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Create artifacts directory
        run: mkdir -p artifacts
        
      - name: Trigger and wait for platform builds
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // éœ€è¦è§¦å‘çš„å·¥ä½œæµåˆ—è¡¨åŠå…¶å¯¹åº”çš„å¹³å°æ£€æŸ¥
            const workflows = [
              { file: 'build-mipsel_24kc-openwrt-21.02.7.yml', platform: 'mipsel-21.02.7' },
              { file: 'build-mipsel_24kc-openwrt-23.05.0.yml', platform: 'mipsel-23.05.0' },
              { file: 'build-x86_64-openwrt-21.02.7.yml', platform: 'x86_64-21.02.7' },
              { file: 'build-x86_64-openwrt-22.03.7.yml', platform: 'x86_64-22.03.7' },
              { file: 'build-x86_64-openwrt-24.10.4.yml', platform: 'x86_64-24.10.4' }
            ];
            
            const selectedPlatform = '${{ needs.check-platforms.outputs.selected-platform }}';
            console.log(`Selected platform: ${selectedPlatform}`);
            
            // è¿‡æ»¤éœ€è¦æ„å»ºçš„å·¥ä½œæµ
            const workflowsToTrigger = workflows.filter(w => {
              if (selectedPlatform === 'all') return true;
              return selectedPlatform === w.platform;
            });
            
            console.log(`Will trigger ${workflowsToTrigger.length} workflows`);
            
            const triggeredRuns = [];
            
            // è§¦å‘å·¥ä½œæµå¹¶è®°å½•è¿è¡ŒID
            for (const workflow of workflowsToTrigger) {
              try {
                console.log(`Triggering ${workflow.file}...`);
                
                // å…ˆè·å–è§¦å‘å‰çš„æœ€æ–°è¿è¡ŒID
                const beforeRuns = await github.rest.actions.listWorkflowRuns({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow.file,
                  per_page: 1
                });
                
                const beforeRunId = beforeRuns.data.workflow_runs.length > 0 ? beforeRuns.data.workflow_runs[0].id : null;
                
                const response = await github.rest.actions.createWorkflowDispatch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  workflow_id: workflow.file,
                  ref: context.ref
                });
                
                console.log(`Triggered ${workflow.file} successfully`);
                
                // ç­‰å¾…æ–°è¿è¡Œå‡ºç°
                let newRunId = null;
                let attempts = 0;
                const maxAttempts = 12; // æœ€å¤šç­‰å¾…60ç§’
                
                while (attempts < maxAttempts && !newRunId) {
                  await new Promise(resolve => setTimeout(resolve, 5000));
                  attempts++;
                  
                  const afterRuns = await github.rest.actions.listWorkflowRuns({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    workflow_id: workflow.file,
                    per_page: 5
                  });
                  
                  // æŸ¥æ‰¾æ–°çš„è¿è¡Œï¼ˆIDä¸åŒäºè§¦å‘å‰çš„è¿è¡Œï¼‰
                  for (const run of afterRuns.data.workflow_runs) {
                    if (run.id !== beforeRunId && run.status !== 'completed') {
                      newRunId = run.id;
                      break;
                    }
                  }
                }
                
                if (newRunId) {
                  triggeredRuns.push({
                    workflow: workflow.file,
                    platform: workflow.platform,
                    runId: newRunId
                  });
                  console.log(`Recorded new run ID ${newRunId} for ${workflow.file}`);
                } else {
                  console.log(`Failed to find new run for ${workflow.file}`);
                }
                
              } catch (error) {
                console.log(`Error triggering ${workflow.file}: ${error.message}`);
              }
            }
            
            console.log(`Triggered ${triggeredRuns.length} workflows, now waiting for completion...`);
            
            // ç­‰å¾…æ‰€æœ‰å·¥ä½œæµå®Œæˆ
            const maxWaitTime = 60 * 60 * 1000; // 1 hour
            const checkInterval = 30 * 1000; // 30 seconds
            const startTime = Date.now();
            
            while (Date.now() - startTime < maxWaitTime) {
              let allCompleted = true;
              
              for (const run of triggeredRuns) {
                if (run.completed) continue;
                
                try {
                  const runDetails = await github.rest.actions.getWorkflowRun({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: run.runId
                  });
                  
                  console.log(`${run.workflow} (${run.runId}): ${runDetails.data.status} - ${runDetails.data.conclusion}`);
                  
                  if (runDetails.data.status === 'completed') {
                    run.completed = true;
                    run.conclusion = runDetails.data.conclusion;
                    console.log(`âœ… ${run.workflow} completed with ${run.conclusion}`);
                  } else {
                    allCompleted = false;
                  }
                } catch (error) {
                  console.log(`Error checking ${run.workflow}: ${error.message}`);
                  allCompleted = false;
                }
              }
              
              if (allCompleted) {
                console.log('ğŸ‰ All workflows completed!');
                break;
              }
              
              console.log('â³ Waiting for workflows to complete...');
              await new Promise(resolve => setTimeout(resolve, checkInterval));
            }
            
            // æ£€æŸ¥æ˜¯å¦è¶…æ—¶
            if (Date.now() - startTime >= maxWaitTime) {
              throw new Error('â° Timeout waiting for workflows to complete');
            }
            
            // æ”¶é›†artifacts
            const artifactsList = [];
            
            for (const run of triggeredRuns) {
              if (run.conclusion === 'success') {
                try {
                  const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    run_id: run.runId
                  });
                  
                  for (const artifact of artifacts.data.artifacts) {
                    console.log(`Found artifact: ${artifact.name} from ${run.workflow}`);
                    artifactsList.push({
                      name: artifact.name,
                      workflow: run.workflow,
                      platform: run.platform,
                      download_url: artifact.archive_download_url,
                      size: artifact.size_in_bytes
                    });
                  }
                } catch (error) {
                  console.log(`Error collecting artifacts from ${run.workflow}: ${error.message}`);
                }
              } else {
                console.log(`âš ï¸ Skipping artifacts from ${run.workflow} (${run.conclusion})`);
              }
            }
            
            // ä¿å­˜artifactsä¿¡æ¯åˆ°ç¯å¢ƒå˜é‡ï¼Œä¾›åç»­æ­¥éª¤ä½¿ç”¨
            fs.writeFileSync('artifacts/artifacts-list.json', JSON.stringify(artifactsList, null, 2));
            console.log(`ğŸ“¦ Collected ${artifactsList.length} artifacts total`);
            
            // å°†æ„ä»¶ä¿¡æ¯ä¿å­˜åˆ°ç¯å¢ƒå˜é‡
            const artifactNames = artifactsList.map(a => a.name).join(',');
            fs.appendFileSync(process.env.GITHUB_ENV, `ARTIFACT_NAMES=${artifactNames}\n`);
            
            return { triggeredRuns, artifactsList };

      - name: Download build artifacts
        if: env.ARTIFACT_NAMES != ''
        run: |
          echo "ğŸ”½ Downloading build artifacts..."
          
          # è¯»å–æ„ä»¶åˆ—è¡¨
          if [ -f "artifacts/artifacts-list.json" ]; then
            echo "Found artifacts list:"
            cat artifacts/artifacts-list.json
            
            # åˆ›å»ºå¹³å°ç›®å½•ç»“æ„
            mkdir -p artifacts/mipsel-21.02.7
            mkdir -p artifacts/mipsel-23.05.0  
            mkdir -p artifacts/x86_64-21.02.7
            mkdir -p artifacts/x86_64-22.03.7
            mkdir -p artifacts/x86_64-24.10.4
            
            echo "âœ… Created platform directories"
          else
            echo "âŒ No artifacts list found"
          fi

      - name: Download individual artifacts
        uses: actions/download-artifact@v4
        if: env.ARTIFACT_NAMES != ''
        with:
          pattern: esurfingclient-*
          path: downloaded-artifacts/
          merge-multiple: false

      - name: Organize downloaded artifacts
        if: env.ARTIFACT_NAMES != ''
        run: |
          echo "ğŸ“ Organizing downloaded artifacts..."
          
          # ç§»åŠ¨ä¸‹è½½çš„æ„ä»¶åˆ°å¯¹åº”çš„å¹³å°ç›®å½•
          if [ -d "downloaded-artifacts" ]; then
            for dir in downloaded-artifacts/*/; do
              if [ -d "$dir" ]; then
                artifact_name=$(basename "$dir")
                echo "Processing $artifact_name..."
                
                # æ ¹æ®æ„ä»¶åç§°ç¡®å®šå¹³å°
                if [[ "$artifact_name" == *"mipsel"* && "$artifact_name" == *"21.02.7"* ]]; then
                  cp -r "$dir"* artifacts/mipsel-21.02.7/
                elif [[ "$artifact_name" == *"mipsel"* && "$artifact_name" == *"23.05.0"* ]]; then
                  cp -r "$dir"* artifacts/mipsel-23.05.0/
                elif [[ "$artifact_name" == *"x86_64"* && "$artifact_name" == *"21.02.7"* ]]; then
                  cp -r "$dir"* artifacts/x86_64-21.02.7/
                elif [[ "$artifact_name" == *"x86_64"* && "$artifact_name" == *"22.03.7"* ]]; then
                  cp -r "$dir"* artifacts/x86_64-22.03.7/
                elif [[ "$artifact_name" == *"x86_64"* && "$artifact_name" == *"24.10.4"* ]]; then
                  cp -r "$dir"* artifacts/x86_64-24.10.4/
                fi
              fi
            done
            
            echo "âœ… Artifacts organized by platform"
            echo "ğŸ“¦ Final structure:"
            find artifacts/ -type f -name "*.ipk" -o -name "*.json" | head -20
          else
            echo "âŒ No downloaded artifacts found"
          fi

      - name: Create build summary
        run: |
          mkdir -p collected-artifacts
          
          # åˆ›å»ºREADMEæ–‡ä»¶
          cat > collected-artifacts/README.md << 'EOF'
          # ESurfing Client Build Artifacts
          
          This package contains build artifacts for multiple OpenWrt platforms.
          
          ## Platforms Included
          
          - **mipsel_24kc OpenWrt 21.02.7** - For older MIPS routers
          - **mipsel_24kc OpenWrt 23.05.0** - For newer MIPS routers  
          - **x86_64 OpenWrt 21.02.7** - For x86_64 systems (older)
          - **x86_64 OpenWrt 22.03.7** - For x86_64 systems (stable)
          - **x86_64 OpenWrt 24.10.4** - For x86_64 systems (latest)
          
          ## Installation Instructions
          
          1. Extract the appropriate package for your platform
          2. Copy the binary to your OpenWrt device
          3. Make it executable: `chmod +x esurfingclient`
          4. Run with appropriate configuration
          
          ## Build Information
          
          - Built with: GitHub Actions
          - Compiler: Cross-compilation toolchain for each platform
          - Build date: $(date)
          
          For more information, visit: https://github.com/$(echo $GITHUB_REPOSITORY)
          EOF
          
          echo "âœ… Created build summary and README"
          echo "### ğŸ“¦ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "Selected platform: ${{ needs.check-platforms.outputs.selected-platform }}" >> $GITHUB_STEP_SUMMARY
          echo "All build artifacts have been collected and uploaded as a unified package." >> $GITHUB_STEP_SUMMARY

      - name: Upload collected artifacts
        uses: actions/upload-artifact@v4
        with:
          name: esurfing-client-all-platforms
          path: |
            collected-artifacts/
            artifacts/
          retention-days: 30
          
      - name: Check overall result
        run: |
          echo "âœ… All selected builds completed successfully"
          echo "ğŸ“¦ Artifacts have been collected and uploaded"